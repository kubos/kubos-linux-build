From 9d26ac808fcfe7bb192d60c707316989f5b8fec3 Mon Sep 17 00:00:00 2001
From: catfreed <catherine@kubos.co>
Date: Fri, 2 Dec 2016 15:29:32 -0600
Subject: [PATCH] Adding configuration files for AT91SAM9G20ISIS board.

---
 arch/arm/include/asm/mach-types.h                |  13 ++
 arch/arm/mach-at91/Kconfig                       |   5 +
 arch/arm/mach-at91/arm926ejs/reset.c             |  14 +-
 board/kubos/at91sam9g20isis/Kconfig              |  12 ++
 board/kubos/at91sam9g20isis/MAINTAINERS          |  17 ++
 board/kubos/at91sam9g20isis/Makefile             |  20 +++
 board/kubos/at91sam9g20isis/at91sam9g20isis.c    | 110 ++++++++++++
 board/kubos/at91sam9g20isis/led.c                |  22 +++
 cmd/gpio.c                                       |   2 +-
 common/image.c                                   |  16 +-
 configs/at91sam9g20kubos_2mmc_norflash_defconfig |  21 +++
 drivers/mmc/gen_atmel_mci.c                      | 204 +++++++++++++++++++++++
 drivers/mmc/mmc.c                                |  38 +++++
 include/common.h                                 |   2 +
 include/configs/at91sam9g20isis.h                | 179 ++++++++++++++++++++
 include/mmc.h                                    |   3 +
 16 files changed, 672 insertions(+), 6 deletions(-)
 create mode 100644 board/kubos/at91sam9g20isis/Kconfig
 create mode 100644 board/kubos/at91sam9g20isis/MAINTAINERS
 create mode 100644 board/kubos/at91sam9g20isis/Makefile
 create mode 100644 board/kubos/at91sam9g20isis/at91sam9g20isis.c
 create mode 100644 board/kubos/at91sam9g20isis/led.c
 create mode 100644 configs/at91sam9g20kubos_2mmc_norflash_defconfig
 create mode 100644 include/configs/at91sam9g20isis.h

diff --git a/arch/arm/include/asm/mach-types.h b/arch/arm/include/asm/mach-types.h
index d51be0b..282f868 100644
--- a/arch/arm/include/asm/mach-types.h
+++ b/arch/arm/include/asm/mach-types.h
@@ -265,6 +265,7 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_TS409                1601
 #define MACH_TYPE_CM_X300              1616
 #define MACH_TYPE_AT91SAM9G20EK        1624
+#define MACH_TYPE_AT91SAM9G20ISIS     1625
 #define MACH_TYPE_SMDK6410             1626
 #define MACH_TYPE_U300                 1627
 #define MACH_TYPE_WRT350N_V2           1633
@@ -4144,6 +4145,18 @@ extern unsigned int __machine_arch_type;
 # define machine_is_at91sam9g20ek()	(0)
 #endif
 
+#ifdef CONFIG_MACH_AT91SAM9G20ISIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G20ISIS
+# endif
+# define machine_is_at91sam9g20isis()	(machine_arch_type == MACH_TYPE_AT91SAM9G20ISIS)
+#else
+# define machine_is_at91sam9g20isis()	(0)
+#endif
+
 #ifdef CONFIG_MACH_SMDK6410
 # ifdef machine_arch_type
 #  undef machine_arch_type
diff --git a/arch/arm/mach-at91/Kconfig b/arch/arm/mach-at91/Kconfig
index 13e19ba..0a8c20e 100644
--- a/arch/arm/mach-at91/Kconfig
+++ b/arch/arm/mach-at91/Kconfig
@@ -30,6 +30,10 @@ config TARGET_GURNARD
 	select DM_SERIAL
 	select DM_GPIO
 	select DM_ETH
+	
+config TARGET_AT91SAM9G20ISIS
+	bool "Kubos at91sam9g20isis board"
+	select CPU_ARM926EJS
 
 config TARGET_AT91SAM9261EK
 	bool "Atmel at91sam9261 reference board"
@@ -175,6 +179,7 @@ source "board/calao/usb_a9263/Kconfig"
 source "board/denx/ma5d4evk/Kconfig"
 source "board/egnite/ethernut5/Kconfig"
 source "board/esd/meesc/Kconfig"
+source "board/kubos/at91sam9g20isis/Kconfig"
 source "board/l+g/vinco/Kconfig"
 source "board/mini-box/picosam9g45/Kconfig"
 source "board/ronetix/pm9261/Kconfig"
diff --git a/arch/arm/mach-at91/arm926ejs/reset.c b/arch/arm/mach-at91/arm926ejs/reset.c
index e67f47b..e4e6e3b 100644
--- a/arch/arm/mach-at91/arm926ejs/reset.c
+++ b/arch/arm/mach-at91/arm926ejs/reset.c
@@ -10,17 +10,25 @@
 #include <asm/io.h>
 #include <asm/arch/hardware.h>
 #include <asm/arch/at91_rstc.h>
+#include <asm/arch/at91sam9_sdramc.h>
 
 /* Reset the cpu by telling the reset controller to do so */
 void reset_cpu(ulong ignored)
 {
 	at91_rstc_t *rstc = (at91_rstc_t *) ATMEL_BASE_RSTC;
+	struct sdramc_reg *ramc = (struct sdramc_reg *)ATMEL_BASE_SDRAMC;
+
+	puts("reset_cpu\r\n");
+
+	//Need to disable running from SDRAM before rebooting or the system will hang
+	writel(1, &ramc->tr);
+	writel(AT91_SDRAMC_LPCB_POWER_DOWN, &ramc->lpr);
 
 	writel(AT91_RSTC_KEY
-		| AT91_RSTC_CR_PROCRST	/* Processor Reset */
-		| AT91_RSTC_CR_PERRST	/* Peripheral Reset */
+		| AT91_RSTC_CR_PROCRST	 /*Processor Reset*/
+		| AT91_RSTC_CR_PERRST	 /*Peripheral Reset*/
 #ifdef CONFIG_AT91RESET_EXTRST
-		| AT91_RSTC_CR_EXTRST	/* External Reset (assert nRST pin) */
+		| AT91_RSTC_CR_EXTRST	 /*External Reset (assert nRST pin)*/
 #endif
 		, &rstc->cr);
 	/* never reached */
diff --git a/board/kubos/at91sam9g20isis/Kconfig b/board/kubos/at91sam9g20isis/Kconfig
new file mode 100644
index 0000000..37eb8dd
--- /dev/null
+++ b/board/kubos/at91sam9g20isis/Kconfig
@@ -0,0 +1,12 @@
+if TARGET_AT91SAM9G20ISIS
+
+config SYS_BOARD
+	default "at91sam9g20isis"
+
+config SYS_VENDOR
+	default "kubos"
+
+config SYS_CONFIG_NAME
+	default "at91sam9g20isis"
+
+endif
diff --git a/board/kubos/at91sam9g20isis/MAINTAINERS b/board/kubos/at91sam9g20isis/MAINTAINERS
new file mode 100644
index 0000000..aa7898e
--- /dev/null
+++ b/board/kubos/at91sam9g20isis/MAINTAINERS
@@ -0,0 +1,17 @@
+AT91SAM9260EK BOARD
+M:	Stelian Pop <stelian@popies.net>
+S:	Maintained
+F:	board/atmel/at91sam9260ek/
+F:	include/configs/at91sam9260ek.h
+F:	configs/at91sam9260ek_dataflash_cs0_defconfig
+F:	configs/at91sam9260ek_dataflash_cs1_defconfig
+F:	configs/at91sam9260ek_nandflash_defconfig
+F:	configs/at91sam9g20ek_2mmc_nandflash_defconfig
+F:	configs/at91sam9g20ek_dataflash_cs0_defconfig
+F:	configs/at91sam9g20ek_dataflash_cs1_defconfig
+F:	configs/at91sam9g20ek_mmc_defconfig
+F:	configs/at91sam9g20ek_2mmc_defconfig
+F:	configs/at91sam9g20ek_nandflash_defconfig
+F:	configs/at91sam9xeek_dataflash_cs0_defconfig
+F:	configs/at91sam9xeek_dataflash_cs1_defconfig
+F:	configs/at91sam9xeek_nandflash_defconfig
diff --git a/board/kubos/at91sam9g20isis/Makefile b/board/kubos/at91sam9g20isis/Makefile
new file mode 100644
index 0000000..17be767
--- /dev/null
+++ b/board/kubos/at91sam9g20isis/Makefile
@@ -0,0 +1,20 @@
+#
+# KubOS Linux
+# Copyright (C) 2016 Kubos Corporation
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+obj-y	+= at91sam9g20isis.o
+obj-y	+= led.o
+
diff --git a/board/kubos/at91sam9g20isis/at91sam9g20isis.c b/board/kubos/at91sam9g20isis/at91sam9g20isis.c
new file mode 100644
index 0000000..0d9b302
--- /dev/null
+++ b/board/kubos/at91sam9g20isis/at91sam9g20isis.c
@@ -0,0 +1,110 @@
+/*
+ * (C) Copyright 2007-2008
+ * Stelian Pop <stelian@popies.net>
+ * Lead Tech Design <www.leadtechdesign.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Modified for Kubos Linux:
+ *   This file was originally based on at91sam920ek.c and
+ *   has been modified for the at91sam9g20isis board.
+ *   Extraneous options have been removed and some code
+ *   to initialize the SD card port has been added.
+ * Author: Catherine Freed <catherine@kubos.co>
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/at91sam9_matrix.h>
+#include <asm/arch/at91sam9_smc.h>
+#include <asm/arch/at91_common.h>
+#include <asm/arch/clk.h>
+#include <asm/arch/gpio.h>
+#include <atmel_mci.h>
+#include <mmc.h>
+
+#include <netdev.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Miscellaneous platform dependent initializations
+ */
+
+#ifdef CONFIG_GENERIC_ATMEL_MCI
+/* this is a weak define that we are overriding */
+int board_mmc_init(bd_t *bd)
+{
+	at91_mci_hw_init();
+
+	debug("board_mmc_init turn on power pin\r\n");
+
+	/* Turn on the SD0 power pin - value must be LOW */
+	at91_set_pio_output(AT91_PIO_PORTB, 6, 0);
+
+	return atmel_mci_init((void *)ATMEL_BASE_MCI);
+}
+#endif
+
+int board_early_init_f(void)
+{
+	at91_periph_clk_enable(ATMEL_ID_PIOA);
+	at91_periph_clk_enable(ATMEL_ID_PIOB);
+	at91_periph_clk_enable(ATMEL_ID_PIOC);
+
+	return 0;
+}
+
+int board_init(void)
+{
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = CONFIG_SYS_SDRAM_BASE + 0x100;
+
+	at91_seriald_hw_init();
+
+	return 0;
+}
+
+int dram_init(void)
+{
+	gd->ram_size = get_ram_size(
+		(void *)CONFIG_SYS_SDRAM_BASE,
+		CONFIG_SYS_SDRAM_SIZE);
+	return 0;
+}
+
+#ifdef CONFIG_RESET_PHY_R
+void reset_phy(void)
+{
+}
+#endif
+
+int board_eth_init(bd_t *bis)
+{
+	int rc = 0;
+#ifdef CONFIG_MACB
+	rc = macb_eth_initialize(0, (void *)ATMEL_BASE_EMAC0, 0x00);
+#endif
+	return rc;
+}
+
+
+void board_isis_mmc_power_init(struct mmc *mmc)
+{
+	struct mmc_cmd cmd;
+	int err;
+
+	udelay(1000);
+
+	cmd.cmdidx = MMC_CMD_GO_IDLE_STATE;
+	cmd.resp_type = MMC_RSP_NONE;
+	cmd.cmdarg = 0;
+
+	err = mmc_send_spcmd(mmc, &cmd, NULL);
+
+	if (err)
+		debug("board_isis_mmc_power_init err=%d\r\n", err);
+
+	udelay(2000);
+}
diff --git a/board/kubos/at91sam9g20isis/led.c b/board/kubos/at91sam9g20isis/led.c
new file mode 100644
index 0000000..fbe15af
--- /dev/null
+++ b/board/kubos/at91sam9g20isis/led.c
@@ -0,0 +1,22 @@
+/*
+ * (C) Copyright 2007-2008
+ * Stelian Pop <stelian@popies.net>
+ * Lead Tech Design <www.leadtechdesign.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/gpio.h>
+#include <status_led.h>
+
+void coloured_LED_init(void)
+{
+	/* Clock is enabled in board_early_init_f() */
+	at91_set_gpio_output(CONFIG_RED_LED, 1);
+	at91_set_gpio_output(CONFIG_GREEN_LED, 1);
+
+	at91_set_gpio_value(CONFIG_RED_LED, 0);
+	at91_set_gpio_value(CONFIG_GREEN_LED, 1);
+}
diff --git a/cmd/gpio.c b/cmd/gpio.c
index ecdc453..9497d2c 100644
--- a/cmd/gpio.c
+++ b/cmd/gpio.c
@@ -230,7 +230,7 @@ static int do_gpio(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	if (ret != -EBUSY)
 		gpio_free(gpio);
 
-	return value;
+	return ret;
 }
 
 U_BOOT_CMD(gpio, 4, 0, do_gpio,
diff --git a/common/image.c b/common/image.c
index a5d19ab..4c9cf4d 100644
--- a/common/image.c
+++ b/common/image.c
@@ -859,22 +859,34 @@ ulong genimg_get_kernel_addr(char * const img_addr)
  */
 int genimg_get_format(const void *img_addr)
 {
+	int rc = 0;
+
 #if defined(CONFIG_IMAGE_FORMAT_LEGACY)
 	const image_header_t *hdr;
 
 	hdr = (const image_header_t *)img_addr;
-	if (image_check_magic(hdr))
+	if ((rc = image_check_magic(hdr)))
+	{
 		return IMAGE_FORMAT_LEGACY;
+	}
+	debug("image_check_magic: %d\r\n", rc);
 #endif
 #if IMAGE_ENABLE_FIT || IMAGE_ENABLE_OF_LIBFDT
-	if (fdt_check_header(img_addr) == 0)
+	if ((rc = fdt_check_header(img_addr)) == 0)
+	{
 		return IMAGE_FORMAT_FIT;
+	}
+	debug("fdt_check_header: %d\r\n", rc);
 #endif
 #ifdef CONFIG_ANDROID_BOOT_IMAGE
 	if (android_image_check_header(img_addr) == 0)
 		return IMAGE_FORMAT_ANDROID;
 #endif
 
+#if !defined(CONFIG_IMAGE_FORMAT_LEGACY) && !IMAGE_ENABLE_FIT && !IMAGE_ENABLE_OF_LIBFDT
+	debug("NOTHING IS DEFINED...\r\n");
+#endif
+
 	return IMAGE_FORMAT_INVALID;
 }
 
diff --git a/configs/at91sam9g20kubos_2mmc_norflash_defconfig b/configs/at91sam9g20kubos_2mmc_norflash_defconfig
new file mode 100644
index 0000000..d9cd7a7
--- /dev/null
+++ b/configs/at91sam9g20kubos_2mmc_norflash_defconfig
@@ -0,0 +1,21 @@
+CONFIG_ARM=y
+CONFIG_ARCH_AT91=y
+CONFIG_TARGET_AT91SAM9G20ISIS=y
+CONFIG_SYS_EXTRA_OPTIONS="AT91SAM9G20,SYS_USE_NORFLASH"
+CONFIG_BOOTDELAY=0
+CONFIG_SYS_PROMPT="U-Boot> "
+# CONFIG_CMD_BDI is not set
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMI is not set
+# CONFIG_CMD_IMLS is not set
+# CONFIG_CMD_LOADS is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_USB=y
+# CONFIG_CMD_FPGA is not set
+# CONFIG_CMD_SOURCE is not set
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_CMD_PING=y
+CONFIG_CMD_FAT=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_OF_LIBFDT=y
diff --git a/drivers/mmc/gen_atmel_mci.c b/drivers/mmc/gen_atmel_mci.c
index cca0b04..ebface6 100644
--- a/drivers/mmc/gen_atmel_mci.c
+++ b/drivers/mmc/gen_atmel_mci.c
@@ -57,6 +57,59 @@ static void dump_cmd(u32 cmdr, u32 arg, u32 status, const char* msg)
 	      cmdr, cmdr & 0x3F, arg, status, msg);
 }
 
+static void mci_set_data_timeout(struct mmc *mmc)
+{
+	atmel_mci_t *mci = (atmel_mci_t *)mmc->priv;
+
+	static const unsigned int dtomul_to_shift[] = {
+		0, 4, 7, 8, 10, 12, 16, 20,
+	};
+
+	unsigned int timeout_ns, timeout_clks;
+	unsigned int dtocyc, dtomul;
+	unsigned int shift;
+	u32 dtor;
+
+	/* we assume 1.5 ms data-read-access-time-1 (taac -> see CSD spec)
+	 * and 0 clock data-read-access-time-2 (nsac -> see CSD spec)
+	 */
+	//timeout_ns = 1500000;
+	timeout_ns = 5000000;
+	timeout_clks = 0;
+
+	debug("gen_atmel_mci: timeout_ns = %u\n", timeout_ns);
+
+	timeout_clks += (((timeout_ns + 9) / 10)
+			 * ((mmc->clock + 99999) / 100000) + 9999) / 10000;
+	if (!IS_SD(mmc))
+		timeout_clks *= 10;
+	else
+		timeout_clks *= 100;
+	debug("gen_atmel_mci: timeout_clks = %u\n", timeout_clks);
+
+	dtocyc = timeout_clks;
+	dtomul = 0;
+	shift = 0;
+	while (dtocyc > 15 && dtomul < 8) {
+		dtomul++;
+		shift = dtomul_to_shift[dtomul];
+		dtocyc = (timeout_clks + (1 << shift) - 1) >> shift;
+	}
+
+	if (dtomul >= 8) {
+		dtomul = 7;
+		dtocyc = 15;
+		puts("Warning: Using maximum data timeout\n");
+	}
+
+	dtor = (MMCI_BF(DTOMUL, dtomul)
+		| MMCI_BF(DTOCYC, dtocyc));
+	writel(dtor, &mci->dtor);
+
+	debug("mci: Using %u cycles data timeout (DTOR=0x%x)\n",
+	       dtocyc << shift, dtor);
+}
+
 /* Setup for MCI Clock and Block Size */
 static void mci_set_mode(struct mmc *mmc, u32 hz, u32 blklen)
 {
@@ -70,6 +123,9 @@ static void mci_set_mode(struct mmc *mmc, u32 hz, u32 blklen)
 
 	debug("mci: bus_hz is %u, setting clock %u Hz, block size %u\n",
 		bus_hz, hz, blklen);
+
+	//mci_set_data_timeout(mmc);
+
 	if (hz > 0) {
 		if (version >= 0x500) {
 			clkdiv = DIV_ROUND_UP(bus_hz, hz) - 2;
@@ -211,6 +267,9 @@ mci_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
 	u32 error_flags = 0;
 	u32 status;
 
+
+	debug("mci_send_cmd\r\n");
+
 	if (!priv->initialized) {
 		puts ("MCI not initialized!\n");
 		return -ECOMM;
@@ -335,6 +394,150 @@ mci_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
 	return 0;
 }
 
+/*
+ * Entered into mmc structure during driver init
+ *
+ * Sends a command out on the bus and deals with the block data.
+ * Takes the mmc pointer, a command pointer, and an optional data pointer.
+ */
+static int
+mci_send_sp_cmd(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
+{
+	struct atmel_mci_priv *priv = mmc->priv;
+	atmel_mci_t *mci = priv->mci;
+	u32 cmdr;
+	u32 error_flags = 0;
+	u32 status;
+
+	debug("mci_send_sp_cmd\r\n");
+
+	if (!priv->initialized) {
+		puts ("MCI not initialized!\n");
+		return -ECOMM;
+	}
+
+	/* Figure out the transfer arguments */
+	cmdr = mci_encode_cmd(cmd, data, &error_flags);
+
+	/* For multi blocks read/write, set the block register */
+	if ((cmd->cmdidx == MMC_CMD_READ_MULTIPLE_BLOCK)
+			|| (cmd->cmdidx == MMC_CMD_WRITE_MULTIPLE_BLOCK))
+		writel(data->blocks | MMCI_BF(BLKLEN, mmc->read_bl_len),
+			&mci->blkr);
+
+	cmdr |= MMCI_BF(SPCMD, MMCI_SPCMD_INIT_CMD);
+	cmdr |= MMCI_BF(OPDCMD, 1);
+
+	/* Send the command */
+	writel(cmd->cmdarg, &mci->argr);
+	writel(cmdr, &mci->cmdr);
+
+#ifdef DEBUG
+	dump_cmd(cmdr, cmd->cmdarg, 0, "DEBUG");
+#endif
+
+	/* Wait for the command to complete */
+	while (!((status = readl(&mci->sr)) & MMCI_BIT(CMDRDY)));
+
+	if ((status & error_flags) & MMCI_BIT(RTOE)) {
+		dump_cmd(cmdr, cmd->cmdarg, status, "Command Time Out");
+		return -ETIMEDOUT;
+	} else if (status & error_flags) {
+		dump_cmd(cmdr, cmd->cmdarg, status, "Command Failed");
+		return -ECOMM;
+	}
+
+	/* Copy the response to the response buffer */
+	if (cmd->resp_type & MMC_RSP_136) {
+		cmd->response[0] = readl(&mci->rspr);
+		cmd->response[1] = readl(&mci->rspr1);
+		cmd->response[2] = readl(&mci->rspr2);
+		cmd->response[3] = readl(&mci->rspr3);
+	} else
+		cmd->response[0] = readl(&mci->rspr);
+
+	/* transfer all of the blocks */
+	if (data) {
+		u32 word_count, block_count;
+		u32* ioptr;
+		u32 sys_blocksize, dummy, i;
+		u32 (*mci_data_op)
+			(atmel_mci_t *mci, u32* data, u32 error_flags);
+
+		if (data->flags & MMC_DATA_READ) {
+			mci_data_op = mci_data_read;
+			sys_blocksize = mmc->read_bl_len;
+			ioptr = (u32*)data->dest;
+		} else {
+			mci_data_op = mci_data_write;
+			sys_blocksize = mmc->write_bl_len;
+			ioptr = (u32*)data->src;
+		}
+
+		status = 0;
+		for (block_count = 0;
+				block_count < data->blocks && !status;
+				block_count++) {
+			word_count = 0;
+			do {
+				status = mci_data_op(mci, ioptr, error_flags);
+				word_count++;
+				ioptr++;
+			} while (!status && word_count < (data->blocksize/4));
+#ifdef DEBUG
+			if (data->flags & MMC_DATA_READ)
+			{
+				u32 cnt = word_count * 4;
+				printf("Read Data:\n");
+				print_buffer(0, data->dest + cnt * block_count,
+					     1, cnt, 0);
+			}
+#endif
+#ifdef DEBUG
+			if (!status && word_count < (sys_blocksize / 4))
+				printf("filling rest of block...\n");
+#endif
+			/* fill the rest of a full block */
+			while (!status && word_count < (sys_blocksize / 4)) {
+				status = mci_data_op(mci, &dummy,
+					error_flags);
+				word_count++;
+			}
+			if (status) {
+				dump_cmd(cmdr, cmd->cmdarg, status,
+					"Data Transfer Failed");
+				return -ECOMM;
+			}
+		}
+
+		/* Wait for Transfer End */
+		i = 0;
+		do {
+			status = readl(&mci->sr);
+
+			if (status & error_flags) {
+				dump_cmd(cmdr, cmd->cmdarg, status,
+					"DTIP Wait Failed");
+				return -ECOMM;
+			}
+			i++;
+		} while ((status & MMCI_BIT(DTIP)) && i < 10000);
+		if (status & MMCI_BIT(DTIP)) {
+			dump_cmd(cmdr, cmd->cmdarg, status,
+				"XFER DTIP never unset, ignoring");
+		}
+	}
+
+	/*
+	 * After the switch command, wait for 8 clocks before the next
+	 * command
+	 */
+	if (cmd->cmdidx == MMC_CMD_SWITCH)
+		udelay(8*1000000 / priv->curr_clk); /* 8 clk in us */
+
+	return 0;
+}
+
 /* Entered into mmc structure during driver init */
 static void mci_set_ios(struct mmc *mmc)
 {
@@ -399,6 +602,7 @@ static const struct mmc_ops atmel_mci_ops = {
 	.send_cmd	= mci_send_cmd,
 	.set_ios	= mci_set_ios,
 	.init		= mci_init,
+	.send_spcmd = mci_send_sp_cmd,
 };
 
 /*
diff --git a/drivers/mmc/mmc.c b/drivers/mmc/mmc.c
index 0312da9..26b7b62 100644
--- a/drivers/mmc/mmc.c
+++ b/drivers/mmc/mmc.c
@@ -136,6 +136,19 @@ int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
 
 	return ret;
 }
+
+int mmc_send_spcmd(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
+{
+	int ret;
+
+	debug("mmc_send_spcmd\r\n");
+
+	mmmc_trace_before_send(mmc, cmd);
+	ret = mmc->cfg->ops->send_spcmd(mmc, cmd, data);
+	mmmc_trace_after_send(mmc, cmd, ret);
+
+	return ret;
+}
 #endif
 
 int mmc_send_status(struct mmc *mmc, int timeout)
@@ -208,9 +221,15 @@ static int mmc_read_blocks(struct mmc *mmc, void *dst, lbaint_t start,
 		cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;
 
 	if (mmc->high_capacity)
+	{
+		debug("Reading high-capacity\r\n");
 		cmd.cmdarg = start;
+	}
 	else
+	{
+		debug("Not reading high-capacity\r\n");
 		cmd.cmdarg = start * mmc->read_bl_len;
+	}
 
 	cmd.resp_type = MMC_RSP_R1;
 
@@ -1567,12 +1586,21 @@ static int mmc_send_if_cond(struct mmc *mmc)
 	err = mmc_send_cmd(mmc, &cmd, NULL);
 
 	if (err)
+	{
+		debug("mmc_send_if_cond err = %d\r\n", err);
 		return err;
+	}
 
 	if ((cmd.response[0] & 0xff) != 0xaa)
+	{
+		debug("mmc_send_if_cond EOPNOTSUPP\r\n");
 		return -EOPNOTSUPP;
+	}
 	else
+	{
+		debug("mmc_send_if_cond setting SD_VERSION_2\r\n");
 		mmc->version = SD_VERSION_2;
+	}
 
 	return 0;
 }
@@ -1582,6 +1610,11 @@ __weak void board_mmc_power_init(void)
 {
 }
 
+/* board-specific MMC power initializations. */
+__weak void board_power_mmc_power_init(void)
+{
+}
+
 int mmc_start_init(struct mmc *mmc)
 {
 	bool no_card;
@@ -1606,6 +1639,7 @@ int mmc_start_init(struct mmc *mmc)
 #ifdef CONFIG_FSL_ESDHC_ADAPTER_IDENT
 	mmc_adapter_card_type_ident();
 #endif
+
 	board_mmc_power_init();
 
 #ifdef CONFIG_DM_MMC_OPS
@@ -1620,6 +1654,10 @@ int mmc_start_init(struct mmc *mmc)
 	mmc_set_bus_width(mmc, 1);
 	mmc_set_clock(mmc, 1);
 
+#ifdef CONFIG_AT91SAM9G20ISIS
+	board_isis_mmc_power_init(mmc);
+#endif
+
 	/* Reset the Card */
 	err = mmc_go_idle(mmc);
 
diff --git a/include/common.h b/include/common.h
index a8d833b..39739ce 100644
--- a/include/common.h
+++ b/include/common.h
@@ -95,6 +95,8 @@ typedef volatile unsigned char	vu_char;
 #define CONFIG_SYS_SUPPORT_64BIT_DATA
 #endif
 
+/*#define DEBUG 1*/
+
 #ifdef DEBUG
 #define _DEBUG	1
 #else
diff --git a/include/configs/at91sam9g20isis.h b/include/configs/at91sam9g20isis.h
new file mode 100644
index 0000000..d3f3464
--- /dev/null
+++ b/include/configs/at91sam9g20isis.h
@@ -0,0 +1,179 @@
+/*
+ * (C) Copyright 2007-2008
+ * Stelian Pop <stelian@popies.net>
+ * Lead Tech Design <www.leadtechdesign.com>
+ *
+ * Configuration settings for the AT91SAM9G20ISIS board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Modified for Kubos Linux:
+ *   This file was originally based on at91sam9260ek.h and
+ *   has been modified for the at91sam9g20isis board.
+ *   Changes:
+ *   	Configuration for NOR flash added
+ *   	Un-needed configurations removed
+ *   	Bootargs to load kernel from SD card added
+ * Author: Catherine Freed <catherine@kubos.co>
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * SoC must be defined first, before hardware.h is included.
+ * In this case SoC is defined in boards.cfg.
+ */
+#include <asm/hardware.h>
+
+/*
+ * CONFIG_SYS_TEXT_BASE - The starting address of U-Boot.
+ * Warning: changing CONFIG_SYS_TEXT_BASE requires
+ * adapting the initial boot program.
+ * Since the linker has to swallow that define, we must use a pure
+ * hex number here!
+ */
+#define CONFIG_SYS_TEXT_BASE		0x20000000
+
+/* ARM asynchronous clock */
+#define CONFIG_SYS_AT91_SLOW_CLOCK	32768		/* slow clock xtal */
+#define CONFIG_SYS_AT91_MAIN_CLOCK	18432000	/* main clock xtal */
+
+/* Define actual evaluation board type from used processor type */
+#ifdef CONFIG_AT91SAM9G20
+# define CONFIG_AT91SAM9G20ISIS	/* It's a Kubos AT91SAM9G20ISIS board*/
+#else
+#error Messed up board configuration!
+#endif
+
+/* Misc CPU related */
+#define CONFIG_ARCH_CPU_INIT
+#define CONFIG_CMDLINE_TAG		/* enable passing of ATAGs */
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_DISPLAY_CPUINFO
+
+/* general purpose I/O */
+#define CONFIG_ATMEL_LEGACY		/* required until (g)pio is fixed */
+#define CONFIG_AT91_GPIO
+#define CONFIG_AT91_GPIO_PULLUP	1	/* keep pullups on peripheral pins */
+
+/* serial console */
+#define CONFIG_ATMEL_USART
+#define CONFIG_USART_BASE		ATMEL_BASE_DBGU
+#define	CONFIG_USART_ID			ATMEL_ID_SYS
+#define CONFIG_BAUDRATE			115200
+
+/* LED */
+#define CONFIG_AT91_LED
+#define	CONFIG_RED_LED		AT91_PIN_PA9	/* this is the power led */
+#define	CONFIG_GREEN_LED	AT91_PIN_PA6	/* this is the user led */
+
+/*
+ * Command line configuration.
+ */
+#define CONFIG_CMD_NOR		1
+
+/*
+ * SDRAM: 1 bank, 32MB
+ * Initialized before u-boot gets started.
+ */
+#define CONFIG_NR_DRAM_BANKS		1
+#define CONFIG_SYS_SDRAM_BASE		ATMEL_BASE_CS1
+#define CONFIG_SYS_SDRAM_SIZE		0x02000000
+
+/*
+ * Initial stack pointer: 4k - GENERATED_GBL_DATA_SIZE in internal SRAM,
+ * leaving the correct space for initial global data structure above
+ * that address while providing maximum stack area below.
+ */
+# define CONFIG_SYS_INIT_SP_ADDR \
+	(ATMEL_BASE_SRAM1 + 0x1000 - GENERATED_GBL_DATA_SIZE)
+
+/*
+ * The (arm)linux board id set by generic code depending on configured board
+ * (see boards.cfg for different boards)
+ */
+#ifdef CONFIG_AT91SAM9G20
+	/* Make sure we're using the right board */
+# ifdef CONFIG_AT91SAM9G20ISIS
+	/* And set the machine type appropriately */
+#  define CONFIG_MACH_TYPE MACH_TYPE_AT91SAM9G20ISIS
+# else
+#  error Unknown bard
+# endif
+#else
+# error Unknown board
+#endif
+
+/* NOR flash */
+#ifdef CONFIG_CMD_NOR
+#define CONFIG_SYS_USE_NORFLASH 1
+#endif
+
+/* MMC - Turned on in defconfig file*/
+#ifdef CONFIG_CMD_MMC
+#define CONFIG_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_GENERIC_ATMEL_MCI
+#endif
+
+/* FAT */
+#ifdef CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#endif
+
+/* USB */
+#define CONFIG_USB_ATMEL
+#define CONFIG_USB_ATMEL_CLK_SEL_PLLB
+#define CONFIG_USB_OHCI_NEW		1
+#define CONFIG_SYS_USB_OHCI_CPU_INIT		1
+#define CONFIG_SYS_USB_OHCI_REGS_BASE		0x00500000	/* AT91SAM9G20_UHP_BASE */
+#define CONFIG_SYS_USB_OHCI_SLOT_NAME		"at91sam9g20"
+#define CONFIG_SYS_USB_OHCI_MAX_ROOT_PORTS	2
+
+#define CONFIG_SYS_LOAD_ADDR			0x21880000	/* load address to load zImage to */
+
+#define CONFIG_SYS_MEMTEST_START		CONFIG_SYS_SDRAM_BASE
+#define CONFIG_SYS_MEMTEST_END			0x20e00000
+
+#if defined(CONFIG_SYS_USE_NORFLASH)
+/* (bootstrap + u-boot + env +dtb in flash) + (linux in mmc) */
+#define CONFIG_ENV_IS_IN_FLASH	1
+#define CONFIG_ENV_OFFSET		0x50000 /* Must start on a sector boundary */
+#define CONFIG_ENV_SIZE		0x10000		/* 1 sector = 65 kB */
+/* Copy .dtb file (NORFLASH @ 0x60000, size = 0x5000) and kernel (SD card, partition 2) into SDRAM, then boot them */
+#define CONFIG_BOOTCOMMAND	"cp.b 0x10060000 0x21800000 0x5000; " \
+				"fatload mmc 0:2 0x21880000 zImage; " \
+				"bootz 0x21880000 - 0x21800000"
+/* Define the initial console connection and rootfs location */
+#define CONFIG_BOOTARGS							\
+	"console=ttyS0,115200 "				\
+	"root=/dev/mmcblk0p3 rootwait"
+
+#define CONFIG_SYS_FLASH_CFI			1
+#define CONFIG_FLASH_CFI_DRIVER			1
+#define PHYS_FLASH_1				0x10000000
+#define CONFIG_SYS_FLASH_BASE			PHYS_FLASH_1
+/* 1 Bank of flash memory.  8 small sectors (8192 bytes),
+ * followed by 15 large sectors (65536 bytes).
+ * Confirm by issuing 'flinfo' command from U-Boot prompt.
+ */
+#define CONFIG_SYS_MAX_FLASH_SECT		23
+#define CONFIG_SYS_MAX_FLASH_BANKS		1
+#endif
+
+#define CONFIG_SYS_CBSIZE		256
+#define CONFIG_SYS_MAXARGS		16
+#define CONFIG_SYS_LONGHELP		1
+#define CONFIG_CMDLINE_EDITING	1
+#define CONFIG_AUTO_COMPLETE
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		ROUND(3 * CONFIG_ENV_SIZE + 128*1024, 0x1000)
+
+#endif
diff --git a/include/mmc.h b/include/mmc.h
index e815eb3..d02e9f7 100644
--- a/include/mmc.h
+++ b/include/mmc.h
@@ -378,6 +378,8 @@ struct mmc_ops {
 	int (*init)(struct mmc *mmc);
 	int (*getcd)(struct mmc *mmc);
 	int (*getwp)(struct mmc *mmc);
+	int (*send_spcmd)(struct mmc *mmc,
+			struct mmc_cmd *cmd, struct mmc_data *data);
 };
 #endif
 
@@ -573,6 +575,7 @@ void mmc_set_preinit(struct mmc *mmc, int preinit);
 struct mmc *mmc_spi_init(uint bus, uint cs, uint speed, uint mode);
 
 void board_mmc_power_init(void);
+void board_isis_mmc_power_init(struct mmc *mmc);
 int board_mmc_init(bd_t *bis);
 int cpu_mmc_init(bd_t *bis);
 int mmc_get_env_addr(struct mmc *mmc, int copy, u32 *env_addr);
-- 
2.7.4

